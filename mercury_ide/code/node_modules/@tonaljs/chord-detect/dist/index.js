(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@tonaljs/chord-type'), require('@tonaljs/core'), require('@tonaljs/pcset')) :
  typeof define === 'function' && define.amd ? define(['exports', '@tonaljs/chord-type', '@tonaljs/core', '@tonaljs/pcset'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ChordDetect = {}, global.chordType, global.core, global.pcset));
}(this, (function (exports, chordType, core, pcset) { 'use strict';

  var namedSet = function (notes) {
      var pcToName = notes.reduce(function (record, n) {
          var chroma = core.note(n).chroma;
          if (chroma !== undefined) {
              record[chroma] = record[chroma] || core.note(n).name;
          }
          return record;
      }, {});
      return function (chroma) { return pcToName[chroma]; };
  };
  function detect(source) {
      var notes = source.map(function (n) { return core.note(n).pc; }).filter(function (x) { return x; });
      if (core.note.length === 0) {
          return [];
      }
      var found = findExactMatches(notes, 1);
      return found
          .filter(function (chord) { return chord.weight; })
          .sort(function (a, b) { return b.weight - a.weight; })
          .map(function (chord) { return chord.name; });
  }
  function findExactMatches(notes, weight) {
      var tonic = notes[0];
      var tonicChroma = core.note(tonic).chroma;
      var noteName = namedSet(notes);
      // we need to test all chormas to get the correct baseNote
      var allModes = pcset.modes(notes, false);
      var found = [];
      allModes.forEach(function (mode, index) {
          // some chords could have the same chroma but different interval spelling
          var chordTypes = chordType.all().filter(function (chordType) { return chordType.chroma === mode; });
          chordTypes.forEach(function (chordType) {
              var chordName = chordType.aliases[0];
              var baseNote = noteName(index);
              var isInversion = index !== tonicChroma;
              if (isInversion) {
                  found.push({
                      weight: 0.5 * weight,
                      name: "" + baseNote + chordName + "/" + tonic,
                  });
              }
              else {
                  found.push({ weight: 1 * weight, name: "" + baseNote + chordName });
              }
          });
      });
      return found;
  }
  var index = { detect: detect };

  exports.default = index;
  exports.detect = detect;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.js.map
