import { get } from '@tonaljs/chord-type';
import { note } from '@tonaljs/core';
import { modes } from '@tonaljs/pcset';

const NotFound = { weight: 0, name: "" };
const namedSet = (notes) => {
    const pcToName = notes.reduce((record, n) => {
        const chroma = note(n).chroma;
        if (chroma !== undefined) {
            record[chroma] = record[chroma] || note(n).name;
        }
        return record;
    }, {});
    return (chroma) => pcToName[chroma];
};
function detect(source) {
    const notes = source.map(n => note(n).pc).filter(x => x);
    if (note.length === 0) {
        return [];
    }
    const found = findExactMatches(notes, 1);
    return found
        .filter(chord => chord.weight)
        .sort((a, b) => b.weight - a.weight)
        .map(chord => chord.name);
}
function findExactMatches(notes, weight) {
    const tonic = notes[0];
    const tonicChroma = note(tonic).chroma;
    const noteName = namedSet(notes);
    const allModes = modes(notes, false);
    const found = allModes.map((mode, chroma) => {
        const chordName = get(mode).aliases[0];
        if (!chordName) {
            return NotFound;
        }
        const baseNote = noteName(chroma);
        const isInversion = chroma !== tonicChroma;
        if (isInversion) {
            return { weight: 0.5 * weight, name: `${baseNote}${chordName}/${tonic}` };
        }
        else {
            return { weight: 1 * weight, name: `${baseNote}${chordName}` };
        }
    });
    return found;
}
var index = { detect };

export default index;
export { detect };
//# sourceMappingURL=index.esnext.js.map
